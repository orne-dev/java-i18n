<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/markdown/strings.md at 2024-10-12
 | Rendered using Apache Maven Fluido Skin 1.12.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>Orne I18N &#x2013; I18N strings</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.12.0.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-1.12.0.min.js"></script>
<script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.4.0/dist/mermaid.esm.min.mjs';
      mermaid.init({ startOnLoad: true });
      document.querySelectorAll('.language-mermaid').forEach(s => s.parentElement.classList.remove("prettyprint"));
      await mermaid.run({
        querySelector: '.language-mermaid',
        suppressErrors: true,
      });
    </script>
  </head>
  <body>
    <a class="github-fork-ribbon right-top" href="https://github.com/orne-dev/java-i18n" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1>Orne I18N</h1>
</div>
</div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2024-10-12<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 0.1.0</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li><a href="index.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="resources.html" title="I18N Resources"><span class="none"></span>I18N Resources</a></li>
    <li class="active"><a><span class="none"></span>I18N Strings</a></li>
    <li><a href="configuration.html" title="Configuration"><span class="none"></span>Configuration</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<h1>I18N strings</h1>
<p>The library provides classes for internationalized strings, compatibles with
Java Beans model. The core interface, <code>I18nString</code> provides methods to
obtain the string current user locale or in an specified locale.</p>
<p>Beans that contain potentially internationalized strings can use the interface
as property type:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">interface MyBean {
    I18nString getDescription();
}
class MyBeanImpl {
    private I18nString description;
    public I18nString getDescription() {
        return this.description;
    }
    public void setDescription(I18nString value) {
        this.description = value;
    }
}
</code></pre></div>
<p>The <code>I18nString</code> interface provides methods to retrieve the <code>String</code> values
for specific languages or for the I18N context's language:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">I18nString value ...;
value.get(); // Returns the text for current language
value.toString(); // Returns the default text
value.get(lang); // Returns the text for specified language
value.get(locale); // Returns the text for specified language
</code></pre></div>
<p>This allows defining data models and APIs that declare potentially
internationalized texts without exposing and/or conditioning the
implementation details.</p><section>
<h2><a name="Implementations"></a>Implementations</h2>
<p>Three implementations are provided &#x201c;out of the box&#x201d;:</p>

<div class="source"><pre class="prettyprint"><code class="language-mermaid">classDiagram
    class I18nString {
        &lt;&lt;interface&gt;&gt;
        get() String
        get(String language) String
        get(Locale locale) String
    }
    class I18nFixedString
    class I18nResourcesString
    class I18nStringMap
    I18nString &lt;|.. I18nFixedString
    I18nString &lt;|.. I18nResourcesString
    I18nString &lt;|.. I18nStringMap
</code></pre></div><section>
<h3><a name="I18nFixedString"></a>I18nFixedString</h3>
<p>Immutable implementation that contains a single shared string for all languages.
To be used when a I18N string is declared (in the API, for example) but it's
known that there is no I18N support for the value.</p>
<p>Use its factory method, <code>I18nFixedString.from(String)</code>
(or the shortcut <code>I18nString.fixed(String)</code>) to create new instances:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">I18nString description = I18nString.fixed(&quot;This text has no translation&quot;);
</code></pre></div></section><section>
<h3><a name="I18nResourcesString"></a>I18nResourcesString</h3>
<p>Immutable implementation based on the application's
<a href="./i18n-resources.html">I18N resources</a> that lazily retrieves text for the
desired language.</p>
<p>Its factory method, <code>I18nResourcesString.forDefault(String)</code>
(or the shortcut <code>I18nString.fromResources(String)</code>),
returns a builder that, after calling <code>build()</code>, creates an immutable instance.</p>

<div class="source"><pre class="prettyprint"><code class="language-java">I18nString description = I18nString.fromResources(&quot;Default text&quot;)
        .ofResources(&quot;my-alt-resources&quot;) // Optional, named I18N resources key
        .withCode(&quot;my.app.i18n.resource&quot;) // Required I18N resources code
        .withCode(&quot;my.app.i18n.alt.resource&quot;) // Optional, fallback I18N resources codes
        .withArg(my) // Optional, arguments to apply to resulting texts
        .build;
</code></pre></div>
<p>This implementation can be used, for example, to provide user friendly
enumeration constant names or descriptions:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">enum MyDiscreteType {
    ...
    CONSTANT_A(&quot;CONSTANT_A&quot;, &quot;my.app.MyDiscreteType.CONSTANT_A&quot;),
    ...
    ;
    private final I18nString description;
    private MyDiscreteType(String defaultDesc, String i18nCode) {
        this.description = I18nString.fromResources(defaultDesc)
            .withCode(i18nCode)
            .build();
    }
    public String getCode() {
        return this.name();
    }
    public I18nString getDescription() {
        return this.description;
    }
</code></pre></div></section><section>
<h3><a name="I18nStringMap"></a>I18nStringMap</h3>
<p>Mutable map-based implementation. Can be used to provide the complete I18N
configuration of, for example, DB backed entities.</p>
<p>Its constructor, <code>I18nStringMap(String)</code>
(or the shortcut <code>I18nString.mapped(String)</code>), creates an instance that accepts
method chaining to set available translations:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">I18nString description = I18nString.mapped(&quot;Default text&quot;)
        .set(Locale.FRENCH, &quot;French translation&quot;)
        .set(&quot;de&quot;, &quot;German translation&quot;);
</code></pre></div></section></section><section>
<h2><a name="Validation"></a>Validation</h2>
<p>Jakarta EE validation support is provided out of the box for the following
constraints:</p>
<ul>

<li>javax.validation.constraints.NotEmpty</li>
<li>javax.validation.constraints.NotBlank</li>
<li>javax.validation.constraints.Size</li>
<li>javax.validation.constraints.Pattern</li>
</ul>
<p>For all constraints, if the I18N string is a <code>I18nStringMap</code> both default text
and defined translations are validated.
Otherwise only the current language's translation (<code>I18nString.get()</code>) is
validated.</p></section><section>
<h2><a name="Jackson_support"></a>Jackson support</h2>
<p>Support is provided for I18N texts serialization and deserialization using
Jackson out-of-the-box.</p>
<p>By default the instances are serialized as a string with the translation
for current I18N context:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">class MyBean {
    private I18nString text;
    // Getter and setter
}

I18N.setLocale(Locale.FRENCH);
MyBean bean = new MyBean();

mapper.writeValueAsString(bean);
// { &quot;text&quot;: null }

bean.setText(fixedI18nString);
mapper.writeValueAsString(bean);
// { &quot;text&quot;: &quot;Fixed text&quot; }

bean.setText(resourcesI18nString);
mapper.writeValueAsString(bean);
// { &quot;text&quot;: &quot;French translation&quot; }

bean.setText(mappedI18nString);
mapper.writeValueAsString(bean);
// { &quot;text&quot;: &quot;French translation&quot; }
</code></pre></div>
<p>To serialize an instance as a JSON object with
all the available translations simply add the Jackson
<code>@JsonFormat(shape = JsonFormat.Shape.OBJECT)</code> annotation:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">class MyBean {
    @JsonFormat(shape = JsonFormat.Shape.OBJECT)
    private I18nString text;
    // Getter and setter
}

I18N.setLocale(Locale.FRENCH);
MyBean bean = new MyBean();

mapper.writeValueAsString(bean);
// { &quot;text&quot;: null }

bean.setText(fixedI18nString);
mapper.writeValueAsString(bean);
// {
//   &quot;text&quot;: {
//     &quot;defaultText&quot;: &quot;Fixed text&quot;,
//     &quot;i18n&quot;: {}
// }

bean.setText(resourcesI18nString);
mapper.writeValueAsString(bean);
// {
//   &quot;text&quot;: {
//     &quot;defaultText&quot;: &quot;Default text&quot;,
//     &quot;i18n&quot;: {
//       &quot;fr&quot;: &quot;French translation&quot;
//     }
// }

bean.setText(mappedI18nString);
mapper.writeValueAsString(bean);
// {
//   &quot;text&quot;: {
//     &quot;defaultText&quot;: &quot;Default text&quot;,
//     &quot;i18n&quot;: {
//       &quot;fr&quot;: &quot;French translation&quot;,
//       &quot;de&quot;: &quot;German translation&quot;,
//     }
// }
</code></pre></div>
<p>Note that when serialized as JSON objects fixed I18N strings provide an empty
<code>i18n</code> object and application resources based instances provide an <code>i18n</code>
object with a single translation for the current locale.
The later behavior is due to the fact that I18N resources don't expose the list
of available languages.</p>
<p>During deserialization a fixed I18N string is created for text JSON nodes and a
mapped I18N string for object JSON nodes:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">class MyBean {
    private I18nString text;
    // Getter and setter
}

MyBean bean = new MyBean();

// { &quot;text&quot;: null }
assertNull(mapper.readValue(json, I18nString.class).getText());

// { &quot;text&quot;: &quot;Some text&quot; }
assertEquals(
        I18nString.fixed(&quot;Some text&quot;),
        mapper.readValue(json, I18nString.class).getText());

// {
//   &quot;text&quot;: {
//     &quot;defaultText&quot;: &quot;Default text&quot;,
//     &quot;i18n&quot;: {
//       &quot;fr&quot;: &quot;French translation&quot;,
//       &quot;de&quot;: &quot;German translation&quot;,
//     }
// }
assertEquals(
        I18nString.mapped(&quot;Default text&quot;)
            .set(&quot;fr&quot;, &quot;French translation&quot;)
            .set(&quot;de&quot;, &quot;German translation&quot;);),
        mapper.readValue(json, I18nString.class).getText());
</code></pre></div>
<p>JSON Schema with I18N types is provided at
<a href="./schema.json">https://orne-dev.github.io/java-i18n/schema.json</a>.</p>
<p>To define a I18n string property just add a reference to
<code>https://orne-dev.github.io/java-i18n/schema.json#string</code> in your JSON schema:</p>

<div class="source"><pre class="prettyprint"><code class="language-json">{
    &quot;$schema&quot;: &quot;https://json-schema.org/draft/2020-12/schema&quot;,
    &quot;$id&quot;: &quot;https://example.com/schemas/bean&quot;,
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
        &quot;text&quot;: { &quot;$ref&quot;: &quot;https://orne-dev.github.io/java-i18n/schema.json#string&quot; }
    }
}
</code></pre></div></section><section>
<h2><a name="JAXB_support"></a>JAXB support</h2>
<p>Support is provided for I18N texts serialization and deserialization using
JAXB out-of-the-box.</p>
<p>XML Schema with I18N types is provided at
<a href="./schema.xsd">https://orne-dev.github.io/java-i18n/schema.xsd</a>.</p>
<p>By default the instances are serialized as a string with the translation
for current I18N context:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">@XmlRootElement(namespace=MyBean.NS, name=MyBean.ROOT)
class MyBean {
    public static final String NS = &quot;http://orne.dev/example&quot;;
    public static final String ROOT = &quot;bean&quot;;
    public static final String TEXT = &quot;text&quot;;
    @XmlElement(namespace=NS, name=TEXT)
    private I18nString text;
    // Getter and setter
}

I18N.setLocale(Locale.FRENCH);
MyBean bean = new MyBean();

marshaller.marshal(bean, out);
// &lt;bean xmlns=&quot;http://orne.dev/example&quot; xmlns:i18n=&quot;http://orne.dev/i18n/&quot;&gt;
//   &lt;text /&gt;
// &lt;/bean&gt;

bean.setText(fixedI18nString);
marshaller.marshal(bean, out);
// &lt;bean xmlns=&quot;http://orne.dev/example&quot; xmlns:i18n=&quot;http://orne.dev/i18n/&quot;&gt;
//   &lt;text&gt;Fixed text&lt;/text&gt;
// &lt;/bean&gt;

bean.setText(resourcesI18nString);
marshaller.marshal(bean, out);
// &lt;bean xmlns=&quot;http://orne.dev/example&quot; xmlns:i18n=&quot;http://orne.dev/i18n/&quot;&gt;
//   &lt;text&gt;French translation&lt;/text&gt;
// &lt;/bean&gt;

bean.setText(mappedI18nString);
marshaller.marshal(bean, out);
// &lt;bean xmlns=&quot;http://orne.dev/example&quot; xmlns:i18n=&quot;http://orne.dev/i18n/&quot;&gt;
//   &lt;text&gt;French translation&lt;/text&gt;
// &lt;/bean&gt;
</code></pre></div>
<p>To serialize an instance with nested elements with all the available
translations simply add the JAXB
<code>@XmlJavaTypeAdapter(I18nStringAdapter.Full.class)</code> annotation:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">@XmlRootElement(namespace=MyBean.NS, name=MyBean.ROOT)
class MyBean {
    public static final String NS = &quot;http://orne.dev/example&quot;;
    public static final String ROOT = &quot;bean&quot;;
    public static final String TEXT = &quot;text&quot;;
    @XmlElement(namespace=NS, name=TEXT)
    @XmlJavaTypeAdapter(I18nStringAdapter.Full.class)
    private I18nString text;
    // Getter and setter
}

I18N.setLocale(Locale.FRENCH);
MyBean bean = new MyBean();

marshaller.marshal(bean, out);
// &lt;bean xmlns=&quot;http://orne.dev/example&quot; xmlns:i18n=&quot;http://orne.dev/i18n/&quot;&gt;
//   &lt;text /&gt;
// &lt;/bean&gt;

bean.setText(fixedI18nString);
marshaller.marshal(bean, out);
// &lt;bean xmlns=&quot;http://orne.dev/example&quot; xmlns:i18n=&quot;http://orne.dev/i18n/&quot;&gt;
//   &lt;text&gt;Fixed text&lt;/text&gt;
// &lt;/bean&gt;

bean.setText(resourcesI18nString);
marshaller.marshal(bean, out);
// &lt;bean xmlns=&quot;http://orne.dev/example&quot; xmlns:i18n=&quot;http://orne.dev/i18n/&quot;&gt;
//   &lt;text&gt;
//     Default text
//     &lt;i18n:translation lang=&quot;fr&quot;&gt;French translation&lt;/i18n:translation&gt;
//   &lt;/text&gt;
// &lt;/bean&gt;

bean.setText(mappedI18nString);
marshaller.marshal(bean, out);
// &lt;bean xmlns=&quot;http://orne.dev/example&quot; xmlns:i18n=&quot;http://orne.dev/i18n/&quot;&gt;
//   &lt;text&gt;
//     Default text
//     &lt;i18n:translation lang=&quot;fr&quot;&gt;French translation&lt;/i18n:translation&gt;
//     &lt;i18n:translation lang=&quot;de&quot;&gt;German translation&lt;/i18n:translation&gt;
//   &lt;/text&gt;
// &lt;/bean&gt;
</code></pre></div>
<p>Note that when serialized with full translation fixed I18N strings provides no
translations and application resources based instances provide a single
translation for the current locale.
The later behavior is due to the fact that I18N resources don't expose the list
of available languages.</p>
<p>During deserialization a fixed I18N string is created for text nodes without
translations and a mapped I18N string for elements with nested translations:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">@XmlRootElement(namespace=MyBean.NS, name=MyBean.ROOT)
class MyBean {
    public static final String NS = &quot;http://orne.dev/example&quot;;
    public static final String ROOT = &quot;bean&quot;;
    public static final String TEXT = &quot;text&quot;;
    @XmlElement(namespace=NS, name=TEXT)
    private I18nString text;
    // Getter and setter
}

MyBean bean = new MyBean();

// &lt;bean xmlns=&quot;http://orne.dev/example&quot; xmlns:i18n=&quot;http://orne.dev/i18n/&quot;&gt;
//   &lt;text /&gt;
// &lt;/bean&gt;
assertNull(unmarshaller.unmarshal(reader).getText());

// &lt;bean xmlns=&quot;http://orne.dev/example&quot; xmlns:i18n=&quot;http://orne.dev/i18n/&quot;&gt;
//   &lt;text&gt;Some text&lt;/text&gt;
// &lt;/bean&gt;
assertEquals(
        I18nString.fixed(&quot;Some text&quot;),
        unmarshaller.unmarshal(reader).getText());

// &lt;bean xmlns=&quot;http://orne.dev/example&quot; xmlns:i18n=&quot;http://orne.dev/i18n/&quot;&gt;
//   &lt;text&gt;
//     Default text
//     &lt;i18n:translation lang=&quot;fr&quot;&gt;French translation&lt;/i18n:translation&gt;
//     &lt;i18n:translation lang=&quot;de&quot;&gt;German translation&lt;/i18n:translation&gt;
//   &lt;/text&gt;
// &lt;/bean&gt;
assertEquals(
        I18nString.mapped(&quot;Default text&quot;)
            .set(&quot;fr&quot;, &quot;French translation&quot;)
            .set(&quot;de&quot;, &quot;German translation&quot;);),
        unmarshaller.unmarshal(reader).getText());

</code></pre></div></section><section>
<h2><a name="Orne_Tests_Generators_support"></a>Orne Tests Generators support</h2>
<p>Generation of random values of <code>I18nString</code> values for testing using
<a class="externalLink" href="https://orne-dev.github.io/java-generators/">Orne Tests Generators</a> is supported out-of-the-box.
All the following will work as expected:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">Generators.randomValue(I18nString.class);
Generators.randomValue(I18nFixedString.class);
Generators.randomValue(I18nStringMap.class);
Generators.randomValue(I18nResourcesString.class);
</code></pre></div>
<p>All the generation parameters and parameters extraction available for string
generation are supported for the generation of default texts and translations.</p>

<div class="source"><pre class="prettyprint"><code class="language-java">Generators.randomValue(
        I18nString.class,
        GenerationParameters.forSizes().withMinSize(5).withMaxSize(10));
</code></pre></div></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>©      2021–2024
<a href="https://github.com/orne-dev">Orne Developments</a>
</p>
        </div>
      </div>
    </footer>
<script>
  if(anchors) {
    anchors.add();
  }
</script>
  </body>
</html>